package Specio::Subs;

use strict;
use warnings;

use Eval::Closure qw( eval_closure );
use Specio::Library::Perl;
use Specio::Registry qw( exportable_types_for_package );
use Try::Tiny;

my $counter = 0;

sub import {
    shift;
    my @libs = @_;

    my $caller = caller();

    my $ident = t('Identifier');

    for my $types ( map { exportable_types_for_package($_) } @libs ) {
        for my $name ( keys %{$types} ) {
            die
                qq{Cannot use '$name' type to create a check sub. It results in an invalid Perl subroutine name}
                unless $ident->check( 'is_' . $name );

            my $type = $types->{$name};

            my $is_name     = 'is_' . $name;
            my $assert_name = 'assert_' . $name;
            if ( $type->can_be_inlined ) {
                _make_sub(
                    $caller, $is_name,
                    $type->inline_check('$_[0]')
                );
                _make_sub(
                    $caller, $assert_name,
                    $type->inline_assert('$_[0]')
                );
            }
            else {
                _install_sub(
                    $caller, $is_name,
                    sub { $type->value_is_valid( $_[0] ) }
                );
                _install_sub(
                    $caller, $assert_name,
                    sub { $type->validate_or_die( $_[0] ) }
                );
            }

            if ( $type->has_coercions ) {
                my $to_name = 'to_' . $name;
                if ( $type->can_inline_coercion ) {
                    _make_sub(
                        $caller, $to_name,
                        $type->inline_coercion('$_[0]')
                    );
                }
                else {
                    _install_sub(
                        $caller, $to_name,
                        sub { $type->coerce_value( $_[0] ) }
                    );
                }

                my $force_name = 'force_' . $name;
                if ( $type->can_inline_coercion_and_check ) {
                    _make_sub(
                        $caller, $force_name,
                        $type->inline_coercion_and_check('$_[0]')
                    );
                }
                else {
                    _install_sub(
                        $caller, $force_name,
                        sub {
                            $type->validate_or_die(
                                $type->coerce_value( $_[0] ) );
                        }
                    );
                }
            }
        }
    }
}

sub _make_sub {
    my $caller   = shift;
    my $sub_name = shift;
    my $source   = shift;
    my $env      = shift;

    my $sub = eval_closure(
        source      => 'sub { ' . $source . ' }',
        environment => $env,
        description => $caller . '::'
            . $sub_name
            . ' generated by '
            . __PACKAGE__,
    );

    _install_sub( $caller, $sub_name, $sub );

    return;
}

my $sub_namer = do {
    try {
        require Sub::Util;
        Sub::Util->VERSION(1.40);
        Sub::Util->can('set_subname');
    }
        or try {
        require Sub::Name;
        Sub::Name->can('subname')
    }
        or sub { return $_[1] };
};

sub _install_sub {
    my $caller   = shift;
    my $sub_name = shift;
    my $sub      = shift;

    my $fq_name = $caller . '::' . $sub_name;

    no strict 'refs';
    *{$fq_name} = $sub_namer->( $fq_name, $sub );

    return;
}

1;
